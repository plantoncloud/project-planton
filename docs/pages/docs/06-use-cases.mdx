# Use Cases and Examples

## Use Case 1: Multi-Cloud Application Deployment

**Scenario**: A development team needs to deploy a microservices-based application across multiple cloud providers to
ensure high availability and reduce dependency on a single vendor.

**How Project Planton Helps**:

- **Unified Configuration**: Developers define their infrastructure and application components in a single YAML manifest
using Project Planton's API resources.
- **Consistent Deployment**: By using the `project-planton` CLI, the team can deploy to AWS, Azure, and Google Cloud
seamlessly without altering the core configuration.
- **Simplified Management**: Updates and scaling can be managed centrally, reducing complexity and potential for errors.

## Use Case 2: Rapid Provisioning of Development Environments

**Scenario**: Individual developers require consistent and isolated development environments that mirror production for
testing new features.

**How Project Planton Helps**:

- **Reusable Manifests**: Developers can use predefined manifests to spin up their environments quickly, ensuring
consistency across the team.
- **Automated Setup**: The Pulumi modules handle the provisioning of necessary resources like Kubernetes clusters,
databases, and networking components.
- **Cost Efficiency**: Environments can be easily destroyed when not needed, optimizing resource usage and cost.

## Use Case 3: Infrastructure Migration

**Scenario**: An organization plans to migrate its applications from one cloud provider to another due to cost or
performance considerations.

**How Project Planton Helps**:

- **Cloud-Agnostic Configuration**: The same manifest can be adapted for different cloud providers with minimal changes.
- **Ease of Transition**: Pulumi modules abstract the underlying cloud specifics, allowing for a smoother migration
process.
- **Risk Mitigation**: Consistent deployment practices reduce the risk of discrepancies between environments.

## Example Manifest

Here's an example of a manifest that deploys a backend api application and its required database:

```yaml
apiVersion: kubernetes.project.planton/v1
kind: MicroserviceKubernetes
metadata:
  name: todo-list-api
spec:
  version: main
  container:
    app:
      env:
        variables:
          DATABASE_NAME: todo
      image:
        repo: nginx
        tag: latest
      ports:
        - appProtocol: http
          containerPort: 8080
          isIngressPort: true
          servicePort: 80
      resources:
        requests:
          cpu: 100m
          memory: 100Mi
        limits:
          cpu: 2000m
          memory: 2Gi
---
apiVersion: kubernetes.project.planton/v1
kind: RedisKubernetes
metadata:
  name: basic-redis
spec:
  container:
    replicas: 1
    resources:
      requests:
        cpu: 50m
        memory: 256Mi
      limits:
        cpu: 1
        memory: 1Gi
    is_persistence_enabled: false
  ingress:
    host: redis.example.com
    tls:
      enabled: true
      secretName: redis-tls
    rules:
      - path: /redis
        backend:
          serviceName: basic-redis-service
          servicePort: 6379
```

**Deployment Command**:

```bash
project-planton pulumi up --manifest ./example-manifest.yaml --kubernetes-cluster ./k8s-cluster.yaml
```

**Explanation**:

- The manifest defines two `DeploymentComponent` resources: one for the web application and one for the database.
- The `web-application` component specifies the Docker image, the number of replicas, and environment variables,
including a reference to database credentials.
- The `database` component defines the database engine, version, storage size, and specifies the cloud provider and
region.
- Running the deployment command will provision both components in the specified cloud environments, using the Pulumi
modules to handle provider-specific details.
